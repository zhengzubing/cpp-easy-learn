- [ ] 继承
    - [ ] protected继承，父类的public成员变量在子类是什么属性？（protected）
    - [ ] 子类内部是否可以访问父类的private成员变量？（no）
    - [ ] 类外是否可以访问到类的protected成员变量？（no）
    - [ ] 构造函数
        - [ ] 实例化子类对象时，子类和父类的构造函数/析构函数的调用顺序？
        - [ ] 初始化列表（区别于先默认初始化再赋值）
            - [ ] const成员变量可以在初始化列表中初始化吗？可以在构造函数中初始化吗？（const成员必须在构造函数初始化列表中初始化）
            - [ ] 只能在初始化列表中初始化的类型（初始化const成员、引用成员、无默认构造函数的对象）
    - [ ] 拷贝构造函数（创建一个已有对象的副本）
        - [ ] 解释下拷贝构造函数
        - [ ] 解释下深拷贝和浅拷贝（浅拷贝只复制对象成员变量的值，析构时会有问题；深拷贝还为动态分配的资源做新分配）
        - [ ] 赋值运算符重载（1. 释放当前对象的资源 2.检查自我赋值 3. 复制参数对象中的资源值）
    - [ ] 赋值运算符重载
        - [ ] 拷贝构造函数和赋值运算符重载的区别？（新对象正在被创建，区别于对象已存在，需要修改其状态）
        - [ ] 拷贝时自我赋值检查？（拷贝赋值和移动赋值需要自我赋值检查，return *this; // 直接返回，不执行任何操作）
    - [ ] 移动构造函数（避免深拷贝，转移资源所有权）
        - [ ] 如果类没有动态申请的资源时，拷贝构造和移动构造在行为上有区别吗？（没有区别，都是浅拷贝）
    - [ ] static变量（生命周期/存储在全局数据区域/文件类可见/静态成员函数/线程安全）
    - [ ] 返回值优化（编译器将函数返回的对象直接构造到它们本来要存储的变量空间中而不产生临时对象）

- [ ] 多态
    - [ ] 解释下多态（一个接口，多种实现，运行时动态确定调用哪个实现）
    - [ ] 引用可以实现多态吗？（可以）
    - [ ] 解释下虚函数指针和虚函数表（虚函数指针每个对象一个，虚函数表每个类一个。子类重写虚函数后覆盖虚函数表中的地址）
    - [ ] 析构函数可以是虚函数吗？（可以）
    - [ ] 虚析构函数的作用？（确保子类析构函数会被调用）
    - [ ] 解释下纯虚函数（virtual = 0）
    - [ ] 构造函数中调用虚函数，可以实现多态吗？（不行）
    - [ ] 解释下override关键字/final关键字

- [ ] C++11
    - [ ] 智能指针
        - [ ] shared_ptr和unique_ptr的区别
        - [ ] 循环引用
        - [ ] unique_ptr，怎么转移？
        - [ ] 自定义删除器（如文件、套接字）
    - [ ] lambda表达式
        - [ ] 值捕获（捕获成const）/引用捕获
        - [ ] 值捕获加后置mutable的作用（值捕获成非const）
        - [ ] // [=]/[=, this] , [=,*this]
        - [ ] 实现原理（匿名函数对象，捕获列表转化为成员变量，重载了operator()）
    - [ ] inline关键字
        - [ ] inline static直接在类内部定义静态成员变量
        - [ ] inline constexpr在头文件中定义全局常量
        - [ ] inline namespace内联命名空间（常用于版本控制）
    - [ ] constexpr关键字
    - [ ] 左值/右值（左值:可寻址  右值:字面量/临时对象）
        - [ ] 左值怎么转换为右值（std::move()）
        - [ ] 完美转发（std::forward，保留参数的左/右值属性，避免临时对象的复制）
    - [ ] 类型转换
        - [ ] dynamic_cast（安全的向下转型，有虚函数）和static_cast的区别，dynamic_cast指针和引用的区别
    - [ ] string
        - [ ] 短字符串优化（栈上预分配内存，减少堆内存分配开销）
        - [ ] 函数参数（const string&）
        - [ ] string_view

- [ ] 内存
    - [ ] new和malloc的区别？new内部做了什么事情？（operator new + placement new/构造函数 + static_cast, operator new内部调用 malloc）
    - [ ] placement new
    - [ ] sizeof 空的 struct的大小是多少? (C++ 要求每个对象必须有唯一的内存地址。如果空结构体大小为 0，则同一类型的多个对象将共享相同的内存地址)
    - [ ] 什么是内存对齐?
    - [ ] new 失败后, 是抛出异常, 还是返回空指针? (默认new 失败时抛出 std::bad_alloc)
    - [ ] operator new 内部默认怎么实现的? (malloc / new handler/ throw)

- [ ] STL
    - [ ] vector
        - [ ] vector内存扩容机制？（size() == capacity()后插入新元素，触发扩容，新申请1.5或者2倍内存，复制或移动原有元素）
        - [ ] 迭代器失效场景？（扩容后）
        - [ ] std::vector在扩容时如何选择拷贝或移动？容器中元素移动构造函数声明noexcept的作用？（扩容时只会调用noexcept的移动构造函数，否则会退回到拷贝）
        - [ ] 已知vector要存储1000个元素，依次push_back，性能方面有什么问题？怎么初始化一个已知要存放1000个元素的vector？（reserve()预分配内存）
    - [ ] deque
        - [ ] deque的内存布局？（分段连续，控制中心，buffer，迭代器）
        - [ ] deque中间插入元素
    - [ ] 容器适配器
        - [ ] stack / queue
    - [ ] 算法
        - [ ] erase + remove_if
    - [ ] 迭代器

- [ ] 模板
    - [ ] 特化（特化为模板指定一个具体的类型或值）
    - [ ] 偏特化（偏特化为模板的部分参数提供具体实现，但仍然保留其他参数的泛型性）
        - [ ] 指针偏特化/引用偏特化/容器偏特化/智能指针偏特化/条件偏特化（enable_if）/递归偏特化
    - [ ] 类型萃取

- [ ] 网络编程
    - [ ] 网络IO模型：阻塞/非阻塞
    - [ ] 多路复用
        - [ ] select和poll/epoll（https://zhuanlan.zhihu.com/p/480599209）
        - [ ] select会把所有要管理的socket的fd传到内核中，socket接收到网卡的数据后，就会去它的睡眠队列里遍历entry，调用entry设置的callback方法，唤醒进程
        - [ ] epoll_ctl
        - [ ] 边沿触发/水平触发

- [ ] 编译
    - [ ] 动态库和静态库的区别
    - [ ] make和cmake的区别

- [ ] 调试
    - [ ] gdb（怎么输出变量值，怎么添加断点，怎么打印堆栈，怎么附加到运行中的进程）

- [ ] 多线程
    - [ ] 创建线程（join和detach的区别，线程创建后是立马开始运行，还是join时开始运行？）
    - [ ] 锁
        - [ ] 解释下死锁
        - [ ] 简单解释下std::lock_guard和std::unique_lock
        - [ ] atomic
        - [ ] 在常成员函数中, 怎么加锁? (mutable)
        - [ ] 读写锁 (shared_mutex + shared_lock/unique_lock)

- [ ] 设计模式
    - [ ] 单例模式
        - [ ] 懒汉/饿汉/static变量
        - [ ] 怎么禁用构造函数（private/=delete）
    - [ ] 工厂模式
        - [ ] 工厂模式的作用（将对象创建逻辑集中到工厂中，使系统更易于维护和扩展）
        - [ ] 简单工厂适合小规模项目，工厂方法适合开闭原则，抽象工厂适合创建相关对象组
    - [ ] 观察者模式

- [ ] OpenGL
    - [ ] 渲染管线
    - [ ] 深度测试
    - [ ] 模板测试