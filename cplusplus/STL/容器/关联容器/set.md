# set 与 unordered_set 简介

## std::set

- 头文件：`<set>`
- 底层结构：红黑树（有序二叉搜索树）
- 主要操作复杂度：插入、删除、查找均为 O(log n)
- 适用场景：需要有序集合，支持范围查询等操作

std::set 的底层是平衡二叉搜索树（如红黑树），元素存储时自动排序且唯一。
如果你通过迭代器修改了某个元素的值，可能会破坏 set 的有序性和唯一性约束，导致容器失效。
set 的迭代器实际是 const int&（或 const 类型的引用），不能通过它写入。

**如果要“修改”元素怎么办？**  
正确做法是：先删掉原有元素，再插入新值。

---

## lower_bound / upper_bound

- `lower_bound(2)` 返回第一个大于等于 2 的元素位置（第一个 2 的位置）。
- `upper_bound(2)` 返回第一个大于 2 的元素位置（3 的位置）。

画个区间示意：

```
[2 2 2]
 ^     ^
 |     |
 |     upper_bound(2)
lower_bound(2)
```

这其实是把所有等于 2 的元素划成区间：  
区间左端点是 `lower_bound(2)`，区间右端点是 `upper_bound(2)`。

- `lower_bound` 就是“左边界”（不小于目标的第一个位置）
- `upper_bound` 就是“右边界”（大于目标的第一个位置）

它们不是“一个找小于等于、一个找大于等于”，而是**共同界定出所有等于某个值的区间**。

---

## std::unordered_set

- 头文件：`<unordered_set>`
- 底层结构：哈希表
- 主要操作复杂度：插入、删除、查找平均 O(1)，最坏 O(n)
- 适用场景：
  - 只关心元素是否存在，不关心顺序
  - 性能需求更高时（哈希表常数时间操作）