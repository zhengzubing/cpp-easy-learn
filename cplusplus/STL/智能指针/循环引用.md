```
class B;  // 前置声明
class A {
public:
    std::shared_ptr<B> ptrB;
};
class B {
public:
    std::shared_ptr<A> ptrA;
};
```

```
auto a = std::make_shared<A>();
auto b = std::make_shared<B>();

a->ptrB = b;
b->ptrA = a;
```

1. 知识点 1：对象的声明周期结束时， 先调用自身的析构函数，再释放成员函数；
2. 知识点 2：new 的对象， 如果不手动调用 delete， 即使函数运行结束， 析构函数也不会被调用；
3. 知识点 3：智能指针退出作用域时， 会调用自身的析构，然后引用计数减 1， 然后判断引用计数是否归零， 决定是否调用指向对象的析构；
4. 当 a 的作用域结束时， 类 A的引用计数减 1， 变成 1, 所以类 A的析构函数此时没有被调用， 则类A 的成员变量也不会被释放， 则类 B的引用计数还是 2； 当 b 的作用域结束时， 类 B的引用计数减 1， 变成 1, 所以类 B的析构函数此时也没有被调用， 则类B 的成员变量也不会被释放, 所以类 A 的引用计数还是 1；
5. 本质类似死锁。A 的析构被调用， 才会释放成员变量，那么才会释放 B； 同时， B 的析构被调用， 才会释放成员变量，那么才会释放 A， 两者都需要析构被调用， 才能释放对方， 但因为都没法释放对方， 也就导致两者的析构都不会被调用。

```
class B;  // 前置声明
class A {
public:
    std::shared_ptr<B> ptrB;
};
class B {
public:
    std::weak_ptr<A> ptrA; // 改为 weak_ptr
};
```

6. 使用weak_ptr后，当 a 的作用域结束时， 类 A的引用计数减 1， 变成 0, 所以类 A的析构函数被调用， 则类A 的成员变量被释放， 则类 B的引用计数变成 1； 当 b 的作用域结束时， 类 B的引用计数减 1， 变成 0, 所以类 B的析构函数被调用， 则类B 的成员变量被释放；
