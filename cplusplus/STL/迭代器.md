# C++ STL 迭代器类型与实现原理

C++标准库（STL）中**迭代器（Iterator）**主要分为以下五种类型，从功能弱到强依次是：

---

## 1. 迭代器的五种类型

1. **Input Iterator（输入迭代器）**
   - 只读、只能单向前进一步。
   - 常用于一次性读取数据流，如 `istream_iterator`。

2. **Output Iterator（输出迭代器）**
   - 只写、只能单向前进一步。
   - 常用于输出到数据流或容器，如 `ostream_iterator`、`back_inserter`。

3. **Forward Iterator（前向迭代器）**
   - 只读或只写，可多次遍历同一元素，单向前进。
   - 如 `std::forward_list`、`std::unordered_map` 的迭代器。

4. **Bidirectional Iterator（双向迭代器）**
   - 可前进和后退。
   - 如 `std::list`、`std::set`、`std::map` 的迭代器。

5. **Random Access Iterator（随机访问迭代器）**
   - 支持所有前面操作，还支持随机访问（可用 `it + n`, `it - n`, `it[n]` 等），类似指针。
   - 如 `std::vector`、`std::deque` 的迭代器。

---

## 2. 迭代器简单实现示例

```cpp
#include <iostream>

class SimpleArray {
    int data[5];
public:
    SimpleArray() : data{1, 2, 3, 4, 5} {}

    // 嵌套迭代器类
    class Iterator {
        int* ptr;
    public:
        Iterator(int* p) : ptr(p) {}
        int& operator*() const { return *ptr; }
        Iterator& operator++() { ++ptr; return *this; }
        bool operator!=(const Iterator& other) const { return ptr != other.ptr; }
    };

    Iterator begin() { return Iterator(data); }
    Iterator end() { return Iterator(data + 5); }
};

int main() {
    SimpleArray arr;
    for (auto it = arr.begin(); it != arr.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;
    // 也可以用范围for
    // for (int v : arr) std::cout << v << " ";
}
```

---

## 3. STL 容器迭代器的实现原理

在现代 C++ STL 实现（如 GCC 的 libstdc++ 和 LLVM 的 libc++）中，容器的迭代器大多数情况下实际上是一个**外部模板类**，而不是容器内部定义的嵌套类本体。容器只是通过 `using` 或 `typedef`，把外部实现的迭代器类型“封装”为自己的嵌套类型。例如：

```cpp
// 外部实现
template<typename _Tp, typename _Ref, typename _Ptr>
class _Vector_iterator { ... };

// vector 内部只是用using
template<typename _Tp, typename _Alloc>
class vector {
public:
    using iterator = _Vector_iterator<_Tp, _Tp&, _Tp*>;
    // ...
};
```

每种容器有各自的迭代器实现，但都暴露统一的标准接口类型。

---

### 为什么用外部模板类实现？

1. **不是为了所有容器都复用同一个迭代器模板类**
   - 不同容器的数据结构和访问方式差异很大，无法用一个统一的迭代器类来兼容（比如 vector 的迭代器是指针，list 的是节点指针，map 的是树节点指针）。
   - “外部模板类”并不是为了所有容器共享同一个迭代器实现。

2. **外部实现的真正意义**
   - **代码复用和多版本支持**  
     有些容器的“const 迭代器”和“普通迭代器”其实可以用同一个外部模板，只需参数不同（如 `_Vector_iterator<T, T*>` 和 `_Vector_iterator<T, const T*>`）。

**示例：**

```cpp
// 外部模板类，Pointer 可以是 T* 或 const T*
template<typename T, typename Pointer>
class _Vector_iterator {
    Pointer ptr;
public:
    _Vector_iterator(Pointer p = nullptr) : ptr(p) {}
    T& operator*() const { return *ptr; }
    _Vector_iterator& operator++() { ++ptr; return *this; }
    bool operator!=(const _Vector_iterator& other) const { return ptr != other.ptr; }
};
```