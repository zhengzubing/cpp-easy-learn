# C++20 协程基础与示例

协程是可以**暂停和恢复**的函数。  
当一个函数包含 `co_await`、`co_yield` 或 `co_return` 时，它就是一个协程。

---

## 1. 基本用法：生成器示例

`co_yield`：每次 `co_yield` 会返回一个值给调用者，然后暂停协程。调用者可以通过协程句柄（如迭代器）逐步获取值。

```cpp
#include <coroutine>
#include <iostream>

struct Generator {
    struct promise_type {
        int current_value;

        Generator get_return_object() {
            return Generator{std::coroutine_handle<promise_type>::from_promise(*this)};
        }
        std::suspend_always initial_suspend() { return {}; }
        std::suspend_always final_suspend() noexcept { return {}; }
        std::suspend_always yield_value(int value) {
            current_value = value;
            return {};
        }
        void return_void() {}
        void unhandled_exception() { std::exit(1); }
    };

    std::coroutine_handle<promise_type> handle;
    Generator(std::coroutine_handle<promise_type> h) : handle(h) {}
    ~Generator() { if (handle) handle.destroy(); }

    struct iterator {
        std::coroutine_handle<promise_type> handle;
        bool operator!=(std::default_sentinel_t) const { return !handle.done(); }
        iterator& operator++() { handle.resume(); return *this; }
        int operator*() const { return handle.promise().current_value; }
    };

    iterator begin() {
        if (handle) handle.resume();
        return iterator{handle};
    }
    std::default_sentinel_t end() { return {}; }
};

Generator generate() {
    co_yield 1;
    co_yield 2;
    co_yield 3;
}

int main() {
    for (int value : generate()) {
        std::cout << value << std::endl; // 输出 1, 2, 3
    }
    return 0;
}
```

---

## 2. 执行流程与迭代器实现

- 调用 `generate()` 时，返回一个 Generator 对象，但不会立即执行协程。
- for 循环调用 `begin()`，启动协程，执行到第一个 `co_yield`，返回值并暂停。
- `operator++` 恢复协程，执行到下一个 `co_yield`，再次返回值并暂停。
- 当协程执行完毕（没有更多 `co_yield`），`done()` 返回 true，迭代结束。

---

## 3. 协程类型与 promise_type

- 协程必须有一个特殊的返回类型（如 `Generator`），它必须定义一个内部的 `promise_type`。
- `initial_suspend()`：协程开始时调用，决定是否立即挂起。
- `yield_value()`：每次 `co_yield` 时调用，协程暂停并返回值。
- `final_suspend()`：协程结束时调用，释放资源。

---

## 4. co_await 与 Awaitable 对象

### 4.1 co_await 关键字

- `co_await` 用于挂起协程，等待异步任务完成。
- 它与 awaitable 对象交互，决定协程是否暂停以及何时恢复。

### 4.2 awaitable 对象示例

一个 awaitable 对象需要实现以下接口：

- `await_ready()`：是否需要暂停协程。
- `await_suspend()`：暂停时的操作，例如注册回调或启动异步任务。
- `await_resume()`：恢复时的操作，例如返回异步任务的结果。

```cpp
#include <coroutine>
#include <thread>
#include <chrono>

struct SimpleAwaitable {
    int delay_in_seconds;

    // 判断是否可以立即完成
    bool await_ready() const noexcept {
        return delay_in_seconds == 0; // 如果延迟为 0，则无需挂起
    }

    // 协程挂起时的操作
    void await_suspend(std::coroutine_handle<> handle) const {
        // 模拟异步操作，启动一个新线程
        std::thread([handle, this]() {
            std::this_thread::sleep_for(std::chrono::seconds(delay_in_seconds)); // 模拟延迟
            handle.resume(); // 恢复协程
        }).detach();
    }

    // 协程恢复时的操作
    void await_resume() const noexcept {
        // 在这里可以返回结果，或者什么都不做
    }
};
```

---

## 5. co_return 的执行流程

- 协程遇到 `co_return`。
- 调用 `promise_type::return_value()` 或 `promise_type::return_void()`。
- 协程可以在 `final_suspend()` 中挂起或销毁。

**co_return 用途：**
- 返回协程的结果。
- 结束协程的执行。