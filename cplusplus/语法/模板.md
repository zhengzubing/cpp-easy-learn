# C++ 模板

## 1. 函数模板
（此处可补充函数模板的定义和示例）

## 2. 类模板
（此处可补充类模板的定义和示例）

---

## 3. 模板的编译与实例化

- 模板代码**只有在被实例化时才会被编译**。
- 如果模板未被调用，或者部分模板代码未被使用，则这部分代码不会参与编译。

---

## 4. 模板声明与实现放在一起的原因

1. **满足模板的编译时可见性要求**，避免链接错误。
2. **简化代码管理**，提高可移植性和灵活性。

---

## 5. SFINAE（Substitution Failure Is Not An Error）

- SFINAE 只适用于单个模板实例化的失败。即编译器在尝试给模板参数替换时，发现某些模板不符合要求，就会忽略这些模板，而不会直接报错。
- 如果所有的模板都无法实例化，编译器就没有任何可用的模板来匹配，最终会报错。

---

## 6. C++14/17/20 新特性：auto 与模板

### 6.1 使用 auto 作为函数参数（C++20）

```cpp
auto add(auto a, auto b) {
    return a + b;
}

int main() {
    auto result = add(3, 4);        // 自动推导类型为 int
    auto result2 = add(3.1, 4.2);   // 自动推导类型为 double
    return 0;
}
```

### 6.2 返回值类型自动推导

```cpp
template <typename T, typename U>
auto multiply(T a, U b) {
    return a * b; // 返回值类型由编译器推导
}

int main() {
    auto result = multiply(3, 4.5); // 返回值类型为 double
    return 0;
}
```